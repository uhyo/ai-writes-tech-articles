---
title: "TypeScript 5.6のIterator Helpersを試して実用性を調べる"
emoji: "🔄"
type: "tech"
topics: ["typescript", "javascript", "ecmascript"]
published: true
---

## はじめに

皆さんこんにちは。2024年9月、TypeScript 5.6がリリースされ、ECMAScript Stage 4のIterator Helpersがサポートされました。**Iterator Helpers**は、配列でおなじみの`map`や`filter`などがイテレータで使えるようになる提案です。

筆者は最初にこの機能を知ったとき「配列メソッドのイテレータ版か」と思ったのですが、実際に試してみると遅延評価の挙動が面白いことに気づきました。この記事では、TypeScript 5.6で使えるIterator Helpersの基本的な使い方から実用性まで調べてみます。

Iterator Helpersは[TC39のproposal-iterator-helpers](https://github.com/tc39/proposal-iterator-helpers)で提案され、Stage 4まで進んだ仕様です。JavaScriptの標準機能として組み込まれるため、外部ライブラリなしで使えます。ただし、ブラウザやNode.jsのバージョンには注意が必要です。

具体的には、Chrome 122以降、Safari 17.4以降、Firefox 131以降で動作します。Node.jsの場合は22.0.0以降が必要です。古い環境をサポートする必要がある場合は、polyfillを使うか、対応を見送る必要があります。

:::message
この記事はTypeScript 5.6時点の挙動です。Iterator HelpersはNode.js 22+またはモダンブラウザ（Chrome 122+など）のランタイムが必要です。
:::

## 基本的な使い方

まず、基本的なIterator Helpersを試してみます。TypeScript 5.6では、ジェネレータ関数が返すイテレータに`map`、`filter`、`take`などのメソッドが生えています。

```typescript
function* numbers() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
}

const doubled = numbers()
  .map(n => n * 2)
  .toArray();

console.log(doubled); // [2, 4, 6, 8, 10]
```

実行すると、配列の`map`と同じように動きました。ここで注目したいのは、`toArray()`を呼ぶまで実際の計算が走らない点です。これは**遅延評価**と呼ばれる挙動で、無限イテレータと組み合わせると便利です。

配列の`map`は即座に全要素を変換して新しい配列を返しますが、イテレータの`map`は変換処理を遅延します。実際の計算が走るのは`toArray()`のような終端操作を呼んだタイミングです。この違いは、大量のデータを扱う場合に重要になります。

次は`filter`と`take`を組み合わせてみます。

```typescript
function* infiniteNumbers() {
  let i = 0;
  while (true) {
    yield i++;
  }
}

const result = infiniteNumbers()
  .filter(n => n % 2 === 0)
  .take(5)
  .toArray();

console.log(result); // [0, 2, 4, 6, 8]
```

無限イテレータから偶数だけ取り出して最初の5個に制限する、というコードです。配列では表現できないパターンが簡潔に書けました。筆者は最初、無限ループになるんじゃないかと心配したのですが、`take`がちゃんと5個で止めてくれます。

このコードが動作する理由は、イテレータが値を1つずつ生成するからです。`filter`で条件に合った値が見つかるたびに、`take`がカウントを進めます。5個集まった時点で、それ以上`infiniteNumbers()`から値を取得しなくなります。これにより無限ループにならずに済むわけです。

## メソッドチェーンと遅延評価

Iterator Helpersの強みは、メソッドチェーンで複雑な処理を書けることです。配列の場合、各メソッド呼び出しで中間配列が作られますが、イテレータは遅延評価なので無駄なメモリ確保がありません。

たとえば配列で`array.filter().map().slice()`と書くと、`filter`の結果配列、`map`の結果配列が一時的に作られます。要素数が100万個あれば、メモリ上に数百万個の値が一時的に存在することになります。イテレータなら、常に現在処理中の1要素だけがメモリに載るため、メモリ効率が大幅に改善されます。

```typescript
function* range(start: number, end: number) {
  for (let i = start; i < end; i++) {
    yield i;
  }
}

const complexResult = range(1, 100)
  .filter(n => n % 3 === 0)  // 3の倍数
  .map(n => n * n)           // 二乗
  .drop(5)                   // 最初の5個をスキップ
  .take(10)                  // 10個取得
  .toArray();

console.log(complexResult);
// [324, 441, 576, 729, 900, 1089, 1296, 1521, 1764, 2025]
```

**drop**は最初のN個をスキップするメソッドです。このコードでは、1から100までの数のうち、3の倍数を二乗して、最初の5個（9, 36, 81, 144, 225）を捨てて、次の10個を取得しています。

この例では4つのメソッドをチェーンしていますが、配列で同じことをすると3つの中間配列が作られます。イテレータなら中間配列はゼロです。処理するデータ量が増えるほど、この差は大きくなります。

筆者がここで気になったのは、本当に遅延評価されているのかという点です。試しに各ステップでログを出してみました。

```typescript
const logged = range(1, 20)
  .map(n => {
    console.log(`map: ${n}`);
    return n * 2;
  })
  .filter(n => {
    console.log(`filter: ${n}`);
    return n > 10;
  })
  .take(3)
  .toArray();

// 出力:
// map: 1
// filter: 2
// map: 2
// filter: 4
// map: 3
// filter: 6
// map: 4
// filter: 8
// map: 5
// filter: 10
// map: 6
// filter: 12  ← ここで1個目
// map: 7
// filter: 14  ← 2個目
// map: 8
// filter: 16  ← 3個目
```

なんと、`take(3)`で3個集まった時点で処理が止まっていました。配列だと全要素を処理してから最初の3個を取り出しますが、イテレータは必要な分だけ処理します。これは大量のデータを扱う場合にパフォーマンス上有利です。

ログを見ると、`map`と`filter`が交互に呼ばれているのがわかります。配列なら「全要素をmapしてから全要素をfilterする」という順番になりますが、イテレータは「1要素をmapしてfilterして次の要素へ」というパイプライン処理になります。このため、必要な結果が得られた時点で残りの要素を処理せずに済むわけです。

## 既存の配列メソッドとの違い

ここまで見てきたように、Iterator Helpersは配列メソッドと似た API ですが、挙動が異なります。主な違いをまとめてみました。

遅延評価に関しては、イテレータは`toArray()`などの終端操作を呼ぶまで値を生成しません。配列は即座に新しい配列を作ります。

メモリ効率の面では、イテレータは一度に1要素ずつ処理するため、中間配列を作りません。配列メソッドは各ステップで新しい配列を確保します。

無限シーケンスの扱いも異なります。イテレータは無限に続くシーケンスを表現できますが、配列は有限です。

処理順序も重要な違いです。配列は各操作ごとに全要素を処理しますが、イテレータは要素ごとに全操作を処理します。この違いがパフォーマンスに影響を与える場合があります。

ただし、イテレータにも制約があります。筆者が試した範囲では、以下の点が気になりました。

まず、イテレータは一度消費すると再利用できません。

```typescript
const iter = numbers().map(n => n * 2);
console.log(iter.toArray()); // [2, 4, 6, 8, 10]
console.log(iter.toArray()); // [] ← 空
```

2回目の`toArray()`呼び出しで空配列が返ってきました。配列なら何度でもアクセスできますが、イテレータは一方通行です。

イテレータを再利用したい場合は、ジェネレータ関数を再度呼び出して新しいイテレータを作る必要があります。この挙動は、ファイルストリームやネットワークストリームのような「一度しか読めないデータ」を扱う場合には自然ですが、単純な数値の配列を扱う感覚で使うと戸惑うかもしれません。

また、TypeScript 5.6では型の扱いに少し癖があります。ECMAScriptの提案では`Iterator.prototype`にメソッドが生えるのですが、TypeScriptには既存の`Iterator`型があるため、新しく**BuiltinIterator**という型が導入されました（[microsoft/TypeScript#58222](https://github.com/microsoft/TypeScript/issues/58222)で議論されています）。

```typescript
// BuiltinIteratorという型が使われる
const iter: BuiltinIterator<number, any, any> = numbers();
```

正直なところ、型名が冗長で扱いづらいと感じました。多くの場合は型推論に任せることになりそうです。将来的にこの型名が改善されるかどうかは不明ですが、現時点では受け入れるしかありません。

## 実用性の評価

実際のプロジェクトでIterator Helpersはどれくらい使えるのでしょうか。筆者なりに使いどころを考えてみました。

適している場面は以下の通りです。

- 大量のデータを段階的に処理する（ログファイルの解析など）
- 無限ストリームやリアルタイムデータの処理
- パイプライン的な処理をメソッドチェーンで表現したい
- メモリ消費を抑えたい場合

逆に、適さない場面もあります。

- 結果を複数回参照したい（配列に変換すれば可能だが、それなら最初から配列でいい）
- ランダムアクセスが必要（イテレータは順方向のみ）
- ブラウザ・Node.jsの古いバージョンをサポートする必要がある
- チーム全体がIterator Helpersに不慣れな場合

筆者は自分のTypeScriptプロジェクトでファイルストリーム処理を書く機会があったのですが、そこでIterator Helpersを試してみたところ、従来のコールバック地獄が解消されて読みやすくなりました。ただし、チームメンバーがまだこの機能を知らなかったため、コードレビューで説明する手間が発生したのは想定外でした。

パフォーマンスに関しては、要素数が少ない場合（数百個程度）は配列とほとんど差がありません。むしろ、イテレータのオーバーヘッドで遅くなる可能性もあります。効果が顕著に現れるのは、数万個以上のデータを扱う場合や、無限ストリームのように終わりがないデータを扱う場合です。

個人的には、Node.js 22がLTSになった今後（2024年10月予定）、徐々に使われていくんじゃないかと思っています。特にRxJSのような重いライブラリを避けたい小規模なストリーム処理には便利そうです。ただし、配列で十分な場面に無理してイテレータを使う必要はないでしょう。

## まとめ

TypeScript 5.6で使えるようになったIterator Helpersを試してみました。配列メソッドと似たAPIで遅延評価の恩恵を受けられるのは魅力的ですが、一方通行な挙動や型の扱いなど、配列とは異なる特性を理解して使う必要があります。

遅延評価の仕組みは興味深く、無限イテレータと組み合わせると配列では不可能な処理が書けます。メソッドチェーンでパイプライン的な処理を表現できるのも便利です。一方で、イテレータの一度しか使えない性質や、`BuiltinIterator`という型名の扱いづらさは、実用上の課題として残ります。

筆者としては、パフォーマンスが重要な大規模データ処理や、無限ストリームを扱う場面では積極的に使っていきたいと感じました。ただし、ランタイム要件（Node.js 22+など）があるため、プロジェクトによっては導入にもう少し時間がかかるかもしれません。

まだ試していない`flatMap`や`reduce`などもあるので、今後さらに使い込んでみて、どんなパターンが有効か探っていきたいと思います。ECMAScriptの仕様として確定した以上、今後どう普及していくのか注目していきたいところです。Iterator Helpersがこれからどう使われていくか、見守っていきたいですね。
